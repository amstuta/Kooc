#!/usr/bin/env python

import os
import cnorm
from user_class import *
from module import *
from implementation import *
from decl_keeper import *
from sys import argv
from pyrser import meta
from pyrser.grammar import Grammar
from cnorm.parsing.statement import Statement
from cnorm.parsing.declaration import Declaration
from os.path import isfile
from cnorm.passes import to_c


execPath = os.getcwd()
filePath = os.path.dirname(os.path.realpath(__file__))


class Kooc(Grammar, Declaration):
    entry = 'translation_unit'
    grammar = """
    declaration = [Declaration.declaration | module | import | implementation | class]
    module = ["@module" id :i Statement.compound_statement :st #add_module(st, i)]
    import = ["@import" '"' [id ".kh"] :i '"' #add_import(current_block, i)]
    implementation = ["@implementation" id :class_name Statement.compound_statement :st #add_implementation(class_name, st)]

    compound_statement = [
    '{'
    __scope__:current_block
    #new_blockstmt(_,current_block)
    [ ["@member" [line_of_code | compound_statement] #add_member(_, current_block) ] | line_of_code]*
    '}'
    ]

    class = ["@class" id :class_name compound_statement :st #add_class(current_block, class_name, st)]
    """
    imports = []

    def __init__(self, flag=False):
        self.recurs = flag
        super(Kooc, self).__init__()


@meta.hook(Kooc)
def add_module(self, statement, ident):
    ident = self.value(ident)
    mod = Module(ident, statement, self.recurs)
    DeclKeeper.instance().add_module(ident, mod)
    return True


@meta.hook(Kooc)
def add_member(self, node, ast):
    if not hasattr(node, 'members'):
        setattr(node, 'members', [])
    node.members.append(ast.ref.body[len(ast.ref.body) - 1])
    ast.ref.body.pop(len(ast.ref.body) - 1)
    return True


@meta.hook(Kooc)
def add_implementation(self, class_name, statement):
    if self.recurs:
        return True
    class_name = self.value(class_name)
    imp = Implementation(class_name, statement)
    DeclKeeper.instance().add_implementation(class_name, imp)
    return True


@meta.hook(Kooc)
def add_class(self, ast, class_name, statement):
    class_name = self.value(class_name)
    cl = Class(class_name, statement, self.recurs)
    DeclKeeper.instance().add_class(class_name, cl)
    tpd = cl.register_typedef()
    ast.ref.body.append(tpd)
    return True


@meta.hook(Kooc)
def add_import(self, ast, ident):
    mod_name = self.value(ident)
    if mod_name in Kooc.imports:
        return True
    a = Kooc(True)
    r = a.parse_file(mod_name)
    for elem in r.body:
        if type(elem) == cnorm.nodes.Decl:
            DeclKeeper.instance().add_id(elem._name)
    inc_name = mod_name.replace('.kh', '.h')
    inc = "#include \"%s\"\n" % inc_name
    raw = cnorm.nodes.Raw(inc)
    ast.ref.body.append(raw)
    return True


def moduleTransfo(ast):
    for mod in DeclKeeper.instance().modules:
        if DeclKeeper.instance().modules[mod].recurs == False:
            for decl in DeclKeeper.instance().modules[mod].decls:
                ast.body.append(DeclKeeper.instance().modules[mod].decls[decl])

    for class_name in DeclKeeper.instance().implementations:
        imp = DeclKeeper().instance().implementations[class_name]
        for i in imp.imps:
            ast.body.append(imp.imps[i])


def main():
    if len(argv) != 2:
        print('Only one parameter required')
        return 1
    inFile = execPath + '/' + argv[1]
    outFile = ''
    if not isfile(inFile):
        print('Given file doesn\'t exist')
        return 1
    if inFile.endswith('.kc'):
        outFile = inFile.replace('.kc', '.c')
    elif inFile.endswith('.kh'):
        outFile = inFile.replace('.kh', '.h')
    else:
        return 1

    a = Kooc()
    res = a.parse_file(inFile)
    moduleTransfo(res)
    fd = open(outFile, 'w+')
    fd.write(str(res.to_c()))
    fd.close()
    return 0
    
    
if __name__ == '__main__':
    main()
