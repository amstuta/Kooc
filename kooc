#!/usr/bin/env python

import os
import cnorm
from user_class import *
from module import *
from implementation import *
from decl_keeper import *
from sys import argv
from pyrser import meta
from pyrser.grammar import Grammar
from cnorm.parsing.statement import Statement
from cnorm.parsing.declaration import Declaration
from os.path import isfile
from cnorm.passes import to_c


execPath = os.getcwd()
filePath = os.path.dirname(os.path.realpath(__file__))


class Kooc(Grammar, Declaration):
    entry = 'translation_unit'
    grammar = """
    declaration = [[Declaration.declaration | module | import | implementation | class] #add_object(current_block)]
    module = ["@module" id :i Statement.compound_statement :st #add_module(st, i)]
    import = ["@import" '"' [id ".kh"] :i '"' #add_import(current_block, i)]

    compound_statement = [
    '{'
    __scope__ :current_block #new_blockstmt(_,current_block)
    [ ["@member" [line_of_code | compound_statement] #add_member(_, current_block) ] | ["@virtual" [line_of_code | compound_statement] #add_virtual(_, current_block)] | line_of_code]*
    '}'
    ]

    class = ["@class" id :class_name #add_type(current_block, class_name) [':' id :parent_class #add_parent(class_name, parent_class) ]? compound_statement :st #add_class(current_block, class_name, st)]


    implementation = ["@implementation" id :class_name imp_compound_st :st #add_implementation(class_name, st)]
    imp_compound_st = [
    '{'
    __scope__ :current_block #new_blockstmt(_, current_block)
    ["@member"? line_of_code]*
    '}'
    ]

    """
    imports = []
    types = None

    def __init__(self, flag=False):
        self.recurs = flag
        super(Kooc, self).__init__()


@meta.hook(Kooc)
def add_object(self, ast):
    ast.ref.types['Object'] = None
    return True


@meta.hook(Kooc)
def add_parent(self, class_name, parent_name):
    DeclKeeper.instance().inher[self.value(class_name)] = self.value(parent_name)
    return True


@meta.hook(Kooc)
def add_virtual(self, node, ast):
    if not hasattr(node, 'virtuals'):
        setattr(node, 'virtuals', [])
    node.virtuals.append(ast.ref.body[len(ast.ref.body) - 1])
    ast.ref.body.pop(len(ast.ref.body) - 1)
    return True


@meta.hook(Kooc)
def add_module(self, statement, ident):
    ident = self.value(ident)
    mod = Module(ident, statement, self.recurs)
    DeclKeeper.instance().add_module(ident, mod)
    return True


@meta.hook(Kooc)
def add_member(self, node, ast):
    if not hasattr(node, 'members'):
        setattr(node, 'members', [])
    node.members.append(ast.ref.body[len(ast.ref.body) - 1])
    ast.ref.body.pop(len(ast.ref.body) - 1)
    return True


@meta.hook(Kooc)
def add_type(self, ast, class_name):
    if Kooc.types == None:
        Kooc.types = ast.ref.types
    ast.ref.types[self.value(class_name)] = None
    Kooc.types[self.value(class_name)] = None
    return True


@meta.hook(Kooc)
def add_implementation(self, class_name, statement):
    if self.recurs:
        return True
    class_name = self.value(class_name)
    imp = Implementation(class_name, statement)
    DeclKeeper.instance().add_implementation(class_name, imp)
    return True


@meta.hook(Kooc)
def add_class(self, ast, class_name, statement):
    class_name = self.value(class_name)
    cl = Class(class_name, statement, self.recurs)
    DeclKeeper.instance().add_class(class_name, cl)
    tpd_vt = cl.register_typedef_vt()
    tpd = cl.register_typedef()
    if tpd_vt != None:
        ast.ref.body.append(tpd_vt)
    ast.ref.body.append(tpd)
    ast.ref.body.extend(cl.protos)
    return True


@meta.hook(Kooc)
def add_import(self, ast, ident):
    mod_name = self.value(ident)
    if mod_name in Kooc.imports:
        return True
    if Kooc.types == None:
        Kooc.types = ast.ref.types
    a = Kooc(True)
    r = a.parse_file(mod_name)
    for elem in r.body:
        if type(elem) == cnorm.nodes.Decl:
            DeclKeeper.instance().add_id(elem._name)
    inc_name = mod_name.replace('.kh', '.h')
    inc = "#include \"%s\"\n" % inc_name
    raw = cnorm.nodes.Raw(inc)
    ast.ref.body.append(raw)
    return True


def moduleTransfo(ast):
    for mod in DeclKeeper.instance().modules:
        if DeclKeeper.instance().modules[mod].recurs == False:
            for decl in DeclKeeper.instance().modules[mod].decls:
                ast.body.append(DeclKeeper.instance().modules[mod].decls[decl])

    for class_name in DeclKeeper.instance().implementations:
        imp = DeclKeeper().instance().implementations[class_name]
        for i in imp.imps:
            ast.body.append(imp.imps[i])


def create_header():
    a = Kooc()
    res = a.parse_file('.kh')
    res.body.insert(0, cnorm.nodes.Raw('#ifndef _H\n#define _H\n'))
    moduleTransfo(res)
    res.body.append(DeclKeeper.instance().obj_vtable)
    res.body.append(cnorm.nodes.Raw('#endif\n'))
    res.body.insert(3, DeclKeeper.instance().typedef_vt_object)
    outFile = execPath + '/.h'
    fd = open(outFile, 'w+')
    fd.write(str(res.to_c()))
    fd.close()


def add_include(ast):
    raw = cnorm.nodes.Raw('#include \".h\"\n')
    ast.body.insert(0, raw)


def add_defines(ast, file_name):
    file_name = file_name[file_name.rfind('/') + 1:]
    define = file_name.replace('.', '_').upper()
    ast.body.insert(0, cnorm.nodes.Raw('#ifndef %s\n' % define))
    ast.body.insert(1, cnorm.nodes.Raw('#define %s\n' % define))
    ast.body.append(cnorm.nodes.Raw('#endif\n'))

    
def main():
    if len(argv) != 2:
        print('Only one parameter required')
        return 1
    inFile = execPath + '/' + argv[1]
    outFile = ''
    if not isfile(inFile):
        print('Given file doesn\'t exist')
        return 1
    if inFile.endswith('.kc'):
        outFile = inFile.replace('.kc', '.c')
    elif inFile.endswith('.kh'):
        outFile = inFile.replace('.kh', '.h')
    else:
        return 1
    create_header()
    a = Kooc()
    res = a.parse_file(inFile)
    add_include(res)
    if 'Object' in DeclKeeper.instance().modules:
        del DeclKeeper.instance().modules['Object']
    moduleTransfo(res)
    if outFile.endswith('.h'):
        add_defines(res, outFile)
    fd = open(outFile, 'w+')
    fd.write(str(res.to_c()))
    fd.close()
    return 0
    
    
if __name__ == '__main__':
    main()
